#!/usr/bin/perl
use strict;
use File::Path;
use File::Path qw(make_path remove_tree);

my $rootdir = $ARGV[0];
if (!-d $rootdir) {
    die "Error: Need a root directory to start working from\n";
}

my $tmpdir = "$rootdir/../___aaa";
if (-d $tmpdir) {
    die "Error: Already exists \"$tmpdir\"\n";
}
make_path($tmpdir);
if (! -d $tmpdir) {
    die "Error: Could not create \"$tmpdir\"\n";
}
rmtree($tmpdir);

cleanup($rootdir);

sub cleanup
{
    my $d = shift;
    my @delete_these = ();
    my @dirs = ();
    my @files = ();

    opendir my $dh, $d or die;
    my @things = readdir $dh;
    closedir $dh;
    for my $thing (@things) {
        next if ($thing eq '.');
        next if ($thing eq '..');
        if ($thing =~ /^\._/) {
            push @delete_these, $thing;
        }
        elsif ($thing =~ /DS_Store/) {
            push @delete_these, $thing;
        }
        elsif ($thing eq '___aaa') {
            push @delete_these, $thing;
        }
        elsif (-d "$d/$thing") {
            push @dirs, $thing;
        }
        elsif (-f "$d/$thing") {
            push @files, $thing;
        }
        else {
            print "==> $d/$thing\n";
        }
    }
    for my $delete_this (@delete_these) {
        if(-f "$d/$delete_this") {
            unlink "$d/$delete_this";
        }
        if(-d "$d/$delete_this") {
            rmtree("$d/$delete_this");
        }
    }
    for my $dir (@dirs) {
        cleanup("$d/$dir");
    }
    make_path($tmpdir);
    my @dirs_and_files = sort by_desired_order (@dirs, @files);
    for my $file (@dirs_and_files) {
        rename "$d/$file", "$tmpdir/$file";
        print("rename \"$d/$file\", \"$tmpdir/$file\"\n");
    }
    for my $file (@dirs_and_files) {
        rename "$tmpdir/$file", "$d/$file";
        print("rename \"$tmpdir/$file\", \"$d/$file\"\n");
    }
    rmtree($tmpdir);
}

sub by_desired_order
{
    my $track1 = '';
    my $name1 = '';
    my $track2 = '';
    my $name2 = '';
    if ($a =~ m{^\s*(\d+)\s*\-\s*(\d+)[\s\-\_]*(.+)}) {
        $track1 = "$1$2";
        $name1 = $3;
    }
    elsif ($a =~ m{^\s*(\d+)[\s\-\_]*(.+)}) {
        $track1 = "$1";
        $name1 = $2;
    }
    if ($b =~ m{^\s*(\d+)\s*\-\s*(\d+)[\s\-\_]*(.+)}) {
        $track2 = "$1$2";
        $name2 = $3;
    }
    elsif ($b =~ m{^\s*(\d+)[\s\-\_]*(.+)}) {
        $track2 = "$1";
        $name2 = $2;
    }
    if (($track1 ne '') and ($track2 eq '')) {
        return -1;
    }
    elsif (($track1 eq '') and ($track2 ne '')) {
        return 1;
    }
    elsif (($track1 eq '') and ($track2 eq '')) {
        return $name1 cmp $name2;
    }
    else {
        if ($track1 == $track2) {
            return $name1 cmp $name2;
        }
        return $track1 <=> $track2;
    }
}

